# Run this in a Jupyter cell to start the updater
import yaml
import json
import time
import requests
import re
import os
from datetime import datetime
from pathlib import Path

print("ğŸš€ Starting IPTV Playlist Auto-Updater...")

# Create output directory
output_dir = Path("auto_updated_playlists")
output_dir.mkdir(exist_ok=True)

# Define playlist sources
PLAYLIST_SOURCES = {
    "all_channels": "https://raw.githubusercontent.com/f/f/main/f.m3u"
}

def fetch_playlist(url):
    """Fetch a playlist from URL"""
    try:
        headers = {'User-Agent': 'Mozilla/5.0'}
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.text
    except Exception as e:
        print(f"âŒ Error fetching {url}: {e}")
        return None

def parse_m3u(content, source_name=""):
    """Parse M3U content"""
    channels = []
    if not content:
        return channels
    
    lines = content.split('\n')
    for i in range(len(lines)):
        line = lines[i].strip()
        if line.startswith('#EXTINF:'):
            info = {'source': source_name}
            
            # Extract info
            logo_match = re.search(r'tvg-logo="([^"]*)"', line)
            info['logo'] = logo_match.group(1) if logo_match else ''
            
            group_match = re.search(r'group-title="([^"]*)"', line)
            info['group'] = group_match.group(1) if group_match else 'General'
            
            parts = line.split(',')
            info['name'] = parts[-1] if len(parts) > 1 else 'Unknown'
            info['extinf_line'] = line  # Store the original EXTINF line
            
            # Get URL
            j = i + 1
            while j < len(lines) and (not lines[j].strip() or lines[j].startswith('#')):
                j += 1
            
            if j < len(lines) and lines[j].strip():
                url = lines[j].strip()
                if url and url.startswith(('http://', 'https://')):
                    info['url'] = url
                    channels.append(info)
    
    return channels

def save_as_m3u8(channels, filename):
    """Save channels as M3U8 file"""
    with open(filename, 'w', encoding='utf-8') as f:
        f.write("#EXTM3U\n")
        f.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total Channels: {len(channels)}\n")
        f.write("# Format: M3U8\n")
        f.write("# Playlist auto-updated\n\n")
        
        for channel in channels:
            # Use original EXTINF line if available, otherwise create one
            if 'extinf_line' in channel:
                f.write(f"{channel['extinf_line']}\n")
            else:
                # Create EXTINF line
                logo_part = f' tvg-logo="{channel.get("logo", "")}"' if channel.get('logo') else ''
                group_part = f' group-title="{channel.get("group", "General")}"' if channel.get('group') else ''
                f.write(f'#EXTINF:-1{logo_part}{group_part},{channel.get("name", "Unknown")}\n')
            
            f.write(f"{channel.get('url', '')}\n")

def update_playlist():
    """Perform a single update"""
    print(f"\nğŸ“… Starting update: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    all_channels = []
    seen_urls = set()
    
    for name, url in PLAYLIST_SOURCES.items():
        print(f"ğŸ“¥ Fetching {name}...")
        content = fetch_playlist(url)
        if content:
            channels = parse_m3u(content, name)
            for channel in channels:
                if channel['url'] not in seen_urls:
                    seen_urls.add(channel['url'])
                    all_channels.append(channel)
            print(f"   âœ… Found {len(channels)} channels")
        else:
            print(f"   âŒ Failed to fetch")
    
    if not all_channels:
        print("âŒ No channels fetched!")
        return False
    
    # Get current time for timestamps
    current_time = datetime.now()
    timestamp = current_time.strftime("%Y%m%d_%H%M%S")
    
    # 1. Save as M3U8 file
    m3u8_file = output_dir / f"playlist_{timestamp}.m3u8"
    save_as_m3u8(all_channels, m3u8_file)
    
    # Also save as latest.m3u8
    latest_m3u8 = output_dir / "latest.m3u8"
    save_as_m3u8(all_channels, latest_m3u8)
    
    # 2. Prepare YAML data (for metadata)
    yaml_data = {
        'metadata': {
            'title': 'IPTV Playlists',
            'description': f'Auto-updated playlist. Last update: {current_time.strftime("%Y-%m-%d %H:%M:%S")}',
            'total_channels': len(all_channels),
            'generated_at': current_time.isoformat(),
            'update_frequency': '5 minutes',
            'format': 'M3U8',
            'encoding': 'UTF-8'
        },
        'sources': list(PLAYLIST_SOURCES.values()),
        'channels': []
    }
    
    # Add channel metadata (first 50 for YAML)
    for i, channel in enumerate(all_channels[:50]):
        yaml_data['channels'].append({
            'id': i + 1,
            'name': channel.get('name', ''),
            'category': channel.get('group', 'General'),
            'logo': channel.get('logo', ''),
            'url': channel.get('url', ''),
            'source': channel.get('source', '')
        })
    
    if len(all_channels) > 50:
        yaml_data['channels'].append({
            'note': f'... and {len(all_channels) - 50} more channels'
        })
    
    # 3. Save YAML (for reference)
    yaml_file = output_dir / f"playlist_metadata_{timestamp}.yml"
    with open(yaml_file, 'w', encoding='utf-8') as f:
        f.write("# Auto-Updated IPTV Playlist Metadata\n")
        f.write("# Updated every 5 minutes\n")
        f.write(f"# Last update: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Corresponding M3U8 file: playlist_{timestamp}.m3u8\n\n")
        yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)
    
    # 4. Save latest YAML
    latest_yaml = output_dir / "latest_metadata.yml"
    with open(latest_yaml, 'w', encoding='utf-8') as f:
        yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)
    
    # 5. Create a combined M3U8 with all channels grouped
    combined_m3u8 = output_dir / f"combined_playlist_{timestamp}.m3u8"
    save_as_m3u8(all_channels, combined_m3u8)
    
    # 6. Create categories M3U8 files
    categories = {}
    for channel in all_channels:
        category = channel.get('group', 'General')
        if category not in categories:
            categories[category] = []
        categories[category].append(channel)
    
    for category, cat_channels in categories.items():
        # Clean category name for filename
        clean_category = re.sub(r'[^\w\s-]', '', category)
        clean_category = re.sub(r'[-\s]+', '_', clean_category).strip('-_')
        
        cat_file = output_dir / f"category_{clean_category}_{timestamp}.m3u8"
        save_as_m3u8(cat_channels, cat_file)
        
        # Also save category latest
        cat_latest = output_dir / f"category_{clean_category}_latest.m3u8"
        save_as_m3u8(cat_channels, cat_latest)
    
    # 7. Create README with links
    readme_file = output_dir / "README.md"
    with open(readme_file, 'w', encoding='utf-8') as f:
        f.write(f"""# Auto-Updated IPTV Playlists

## Last Update: {current_time.strftime('%Y-%m-%d %H:%M:%S')}
## Total Channels: {len(all_channels)}

## Available Playlists:

### Main Playlists:
1. **[latest.m3u8](latest.m3u8)** - Always the latest playlist
2. **[playlist_{timestamp}.m3u8](playlist_{timestamp}.m3u8)** - Timestamped version
3. **[combined_playlist_{timestamp}.m3u8](combined_playlist_{timestamp}.m3u8)** - Combined playlist

### Category Playlists:
""")
        
        for category in sorted(categories.keys()):
            clean_category = re.sub(r'[^\w\s-]', '', category)
            clean_category = re.sub(r'[-\s]+', '_', clean_category).strip('-_')
            count = len(categories[category])
            f.write(f"- [{category}](category_{clean_category}_latest.m3u8) ({count} channels)\n")
        
        f.write(f"""
### Metadata:
- [playlist_metadata_{timestamp}.yml](playlist_metadata_{timestamp}.yml) - Channel metadata
- [latest_metadata.yml](latest_metadata.yml) - Latest metadata

## Usage:
Copy the M3U8 URL and paste it into your IPTV player.

## Update Frequency:
Every 5 minutes

## Sources:
""")
        
        for name, url in PLAYLIST_SOURCES.items():
            f.write(f"- {name}: {url}\n")
        
        f.write(f"""
---
*Auto-generated on {current_time.strftime('%Y-%m-%d %H:%M:%S')}*
""")
    
    print(f"\nâœ… Update completed!")
    print(f"   ğŸ“Š Total channels: {len(all_channels)}")
    print(f"   ğŸ“ Files saved in: {output_dir}/")
    print(f"\n   ğŸ’¾ M3U8 Files:")
    print(f"     - latest.m3u8 (always latest)")
    print(f"     - playlist_{timestamp}.m3u8 (timestamped)")
    print(f"     - combined_playlist_{timestamp}.m3u8")
    
    print(f"\n   ğŸ“‹ Category Files:")
    for category in sorted(categories.keys())[:5]:  # Show first 5 categories
        count = len(categories[category])
        clean_category = re.sub(r'[^\w\s-]', '', category)
        clean_category = re.sub(r'[-\s]+', '_', clean_category).strip('-_')
        print(f"     - category_{clean_category}_latest.m3u8 ({count} channels)")
    
    if len(categories) > 5:
        print(f"     - ... and {len(categories) - 5} more categories")
    
    print(f"\n   ğŸ“„ Metadata:")
    print(f"     - playlist_metadata_{timestamp}.yml")
    print(f"     - latest_metadata.yml")
    print(f"     - README.md")
    
    return True

# Run the update
success = update_playlist()

if success:
    print("\nğŸ‰ Check the 'auto_updated_playlists' folder for your M3U8 files!")
    print("   You can use these URLs in your IPTV player:")
    print(f"   - Direct URL to latest: file://{output_dir.absolute()}/latest.m3u8")
    print(f"   - Or copy the file to your device")
else:
    print("\nâš ï¸  Update failed. Check the error messages above.")
